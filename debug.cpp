/*
 *  This file is part of ONTotalRecaller.
 *  Copyright (c) by
 *  Nicola Prezza 		<nicolapr@gmail.com>
 *  Bud Mishra 			<mishra@nyu.edu>
 *  Giuseppe Narzisi	<gnarzisi@nygenome.org>
 *
 *  ONTotalRecaller is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.

 *  ONTotalRecaller is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details (<http://www.gnu.org/licenses/>).
 */

/*
 * debug.cpp
 *
 *  Created on: Jun 12, 2015
 *      Author: nicola
 */

#include <string>
#include <iostream>

#include <definitions.hpp>
#include <fmi_trie.hpp>
#include <nanopore_signal.hpp>
#include <on_hmm.hpp>
#include <total_recaller.hpp>

//#include <fast5.hpp>
//#include <kmer.hpp>

using namespace std;
using namespace sdsl;
using namespace ontrc;


void test_hdf5_file(string file_name){

    // Open the FAST5 file for reading
    fast5::File* f_p;
    f_p = new fast5::File(file_name);

    // Check that it opened successfully
    assert(f_p->is_open());

    // Extract version information for the ONT software used to generate this dataset
    cout << "file_version=" << f_p->file_version() << endl;
    cout << "basecall_version=" << f_p->basecall_version() << endl;
    cout << "eventdetection_version=" << f_p->eventdetection_version() << endl;
    cout << "sequences_version=" << f_p->sequences_version() << endl;

    ulint bad_signals=0, good_signals=0;

    // This function checks to see if 2D basecalls are available
    if(f_p->have_basecalled_2D())
    {

    	cout << f_p->get_events(0).size() << " template events " << endl;
    	cout << f_p->get_events(1).size() << " complment events " << endl;
    	cout << "called sequence length = " << f_p->basecalled_2D().size() << endl;
    	cout << "template events/base = " << (double)f_p->get_events(0).size()/f_p->basecalled_2D().size() << endl;
    	cout << "complement events/base = " << (double)f_p->get_events(1).size()/f_p->basecalled_2D().size() << endl;

        // cout << "basecalled_2D=" << f_p->basecalled_2D() << endl;

        // Extract the alignment between template and complement events
        // which were generated by the 2D basecaller
        auto v = f_p->get_event_alignments();
        cout << "event_alignment().size()=" << v.size() << endl;

        double sr = f_p->get_sampling_rate();
        nanopore_signal ns_t(*f_p,COMPLEMENT);

        double sum_prob=0;
        double sum_logs=0;

        for (const auto& e : v)
        {

        	double llh = 1;
        	double var=0,mu=0, var_sd, mu_sd;
        	event evv;
        	kmer km;

        	if(e.complement_index>=0){


        		evv = ns_t[e.complement_index];
        		km = kmer(string(e.kmer)).rev_compl();

        		var = ns_t.stdev(km);
        		mu = ns_t.mean(km);

        		var_sd = ns_t.sd_stdev(km);
        		mu_sd = ns_t.sd_mean(km);

        		llh = ns_t.log_P(evv,km);

        		//cout << km.to_string() << " " << llh << " " << exp(llh) << endl;

        	}

        	double prob = (llh>0?0:exp(llh));

        	if(prob>0)
        		if(prob<0.05) bad_signals++; else good_signals++;

        	sum_prob+=prob;
        	if(prob>0) sum_logs+=log(prob);

        	//if(prob>0) cout << evv.number_of_samples << "\t" << square(evv.mean-mu) << endl;
        	//if(prob>0) cout << evv.number_of_samples << "\t" << square(evv.stdv-var) << endl;

/*        	cout << "observed mean = " << evv.mean << endl;
        	cout << "observed stdev = " << evv.stdv << endl;
        	cout << "number of samples = " << evv.number_of_samples << endl;
        	cout << "th mean = " << mu << endl;
        	cout << "th stdev = " << var << endl;
        	cout << "th sd_mean = " << mu_sd << endl;
        	cout << "th sd_stdev = " << var_sd << endl;
        	cout << "llh = " << ns_t.log_P(evv,km) << endl;
        	cout << "P = " << exp(ns_t.log_P(evv,km)) << endl<<endl;*/


        }

        cout << "Good = " << good_signals << ", bad = " << bad_signals << endl;
        cout << "Sum = " << sum_prob<<endl;
        cout << "Sum logs = " << sum_logs<<endl;

    }

    /*
    // Iterate over the template/complement strands
    for (size_t i = 0; i < 2; ++i)
    {
        // Check if a pore model for this strand exists
        if (f_p->have_model(i))
        {
            // Print the name of ONT's reference model used to basecall
            cout << "Model file: " << f_p->get_model_file(i) << endl;

            // Extract the global scaling parameters for the pore model
            auto params = f_p->get_model_parameters(i);
            cout << "model drift=" << params.drift <<
                    ", scale="     << params.scale <<
                    ", scale_sd="  << params.scale_sd <<
                    ", shift="     << params.shift <<
                    ", var="       << params.var <<
                    ", var_sd="    << params.var_sd << endl;

            // Extract the expected current levels for each k-mer
            auto v = f_p->get_model(i);
            cout << "model(" << i << ").size()=" << v.size() << endl;
            for (const auto& e : v)
            {
                cout << "(kmer=" << e.kmer << ", level_mean=" << e.level_mean << ", level_stdv=" << e.level_stdv << ")" << endl;
            }
        }

        // Check if this strand has event observations
        if (f_p->have_events(i))
        {
            // Extract each event
            auto v = f_p->get_events(i);
            cout << "events(" << i << ").size()=" << v.size() << endl;
            for (const auto& e : v)
            {
                cout << "(mean=" << e.mean << ", start=" << e.start << ", stdv=" << e.stdv << ", length=" << e.length << ")" << endl;
            }
        }
    }*/

    // Cleanup the file pointer, which closes the file
    delete f_p;

}

void print_called(char** argv){

	string fast5_file(argv[1]);

    fast5::File f_p(fast5_file);

    nanopore_signal ns_t(f_p,TEMPLATE);

    ulint tot_samples=0;

    // This function checks to see if 2D basecalls are available
    if(f_p.have_basecalled_2D())
    {
        cout << f_p.basecalled_2D() << endl;
    }

}

void display_fast5(string filename){

    fast5::File f_p(filename);

    nanopore_signal ns_t(f_p,TEMPLATE);
    nanopore_signal ns_c(f_p,COMPLEMENT);

    ulint tot_samples=0;

/*    for(ulint i=0;i<ns_t.size();++i){
    	cout << ns_t[i].length << " " <<  ns_t[i].number_of_samples << endl;
    	tot_samples += ns_t[i].number_of_samples;
    }*/

    //cout << "Average number of samples is " << (double)tot_samples/ns_t.size()<<endl;

/*    for(kmer km;km < ns_t.number_of_kmers();km++){

    	cout << km.to_string() << " -> " << ns_t.get_distribution(km).mean << " " << ns_t.get_distribution(km).stdev << endl;
    	cout << km.to_string() << " -> " << ns_c.get_distribution(km).mean << " " << ns_c.get_distribution(km).stdev << endl<<endl;

    }
    */
    // This function checks to see if 2D basecalls are available
    if(f_p.have_basecalled_2D())
    {
        cout << "basecalled_2D=" << f_p.basecalled_2D() << endl;

        // Extract the alignment between template and complement events
        // which were generated by the 2D basecaller
/*        auto v = f_p.get_event_alignments();
        cout << "event_alignment().size()=" << v.size() << endl;
        for (const auto& e : v)
        {
            cout << "(template=" << e.template_index << ", complement=" << e.complement_index << ", kmer=" << e.kmer << ")" << endl;
        }*/
    }

}

void test_fmi(string input, string fileout){

/*	fmi_trie fmi(input);
	fmi.save_to_disk(fileout);

	auto n = fmi.get_root();
	cout << fmi.count(n)<<endl;

	n = fmi.get_child(n,'i');
	cout << fmi.count(n)<<endl;

	n = fmi.get_child(n,'s');
	cout << fmi.count(n)<<endl;

	n = fmi.get_child(n,'s');
	cout << fmi.count(n)<<endl;

	n = fmi.get_child(n,'i');
	cout << fmi.count(n)<<endl;

	n = fmi.get_child(n,'p');
	cout << fmi.count(n)<<endl;*/
}

void build_tree(on_hmm::node_t& parent, on_hmm& hmm, nanopore_signal& ns_t, string& seq, ulint pos){

	if(pos<seq.size()){

		auto x = hmm.get_child(parent,char_to_base(seq[pos]));

		//cout << x.get_max_V_idx() << endl;

/*		auto idx = x.get_max_V_idx();

		ulint l = (idx<10?0:idx-10);

		for(ulint i=l;i<idx+10;++i)
			cout << x.V(i) << " " ;

		cout << endl;*/

		//if(seq.size()-pos <1000) cout << seq.size()-pos << " : " << hmm.score_last(x) << endl;

		build_tree(x, hmm, ns_t, seq, pos+1);

	}else{

/*		cout << "checking tree ... "<<flush;
		parent.check_tree();
		cout << "ok!"<<endl;*/
		cout << "Computing loglikelihood ... " << endl;

		cout << "LLH = " << hmm.log_likelihood(parent, ns_t.size()-1) << endl ;

	}

}


void compute_llh_uniform(char** argv){

	string fast5_file(argv[1]);
	string param_file(argv[2]);
	ulint event_prefix_len = atoi(argv[3]);
	ulint seq_prefix_len = atoi(argv[4]);

    fast5::File f_p(fast5_file);
    nanopore_signal ns_t(f_p,TEMPLATE);

    vector<ontrc::event> subsample;
    for(ulint i=0;i<event_prefix_len;++i)
    	subsample.push_back( ns_t.get_event(i) );
    ns_t.replace_events(subsample);

	string seq = string();

	on_hmm::parameters_t param;
	param.load_from_file(param_file);

	on_hmm hmm(&ns_t,500,param);

	//scramble sequence
	//srand(time(NULL)); ulint nr_changes=0; for(ulint i=0;i<nr_changes;++i) seq[rand()%seq.size()] = base_to_char(base(rand()%4));

	//TODO uniform random sequence
	srand(time(NULL)); for(ulint i=0;i<seq_prefix_len;++i) seq += base_to_char(base(rand()%4));

	cout << seq<<endl;

	double llh = hmm.log_likelihood(seq, event_prefix_len);

	cout << "LLH = " << llh << endl;

}

void test_SNPs_llh(char** argv){

	string fast5_file(argv[1]);
	string fasta_file(argv[2]);
	string param_file(argv[3]);
	ulint prefix_len = atoi(argv[4]);

    fast5::File f_p(fast5_file);
    nanopore_signal ns_t(f_p,TEMPLATE);

    vector<ontrc::event> subsample;
    for(ulint i=0;i<prefix_len;++i)
    	subsample.push_back( ns_t.get_event(i) );
    ns_t.replace_events(subsample);

	string seq_orig = read_fasta_file(fasta_file);

	on_hmm::parameters_t param;
	param.load_from_file(param_file);

	on_hmm hmm(&ns_t,prefix_len,param);

	double orig_llh = hmm.log_likelihood(seq_orig, prefix_len);

	ulint nr_accepted_mutations=0;

	cout << "seq size = " << seq_orig.size() << endl;

	for(ulint pos=0;pos<seq_orig.size();++pos){

		bool found = false;//accepted mutation found

		//try all 3 possible substitutions
		for(ulint k=1;k<4 and not found;++k){

			string seq_copy(seq_orig);
			ulint bo = char_to_base((uchar)seq_copy[pos]);
			ulint b_new = (bo + k) % 4;
			seq_copy[pos] = base_to_char( base( b_new ) ) ;

			double llh = hmm.log_likelihood(seq_copy, prefix_len);

			if(llh>orig_llh){

				nr_accepted_mutations++;
				found=true;

			}

		}

		if(pos%10==0) cout << pos << endl;

	}

	cout << endl;

	cout << "Number of accepted mutations/positions = " << nr_accepted_mutations << "/" << seq_orig.length() << endl;
	cout << "Sequence identity = " << 100-100*(double)nr_accepted_mutations/(double)seq_orig.length()<<"%"<<endl;

}

void compute_llh(char** argv){

	string fast5_file(argv[1]);
	string fasta_file(argv[2]);
	string param_file(argv[3]);
	ulint prefix_len = atoi(argv[4]);

    fast5::File f_p(fast5_file);
    nanopore_signal ns_t(f_p,TEMPLATE);

    vector<ontrc::event> subsample;
    for(ulint i=0;i<prefix_len;++i)
    	subsample.push_back( ns_t.get_event(i) );
    ns_t.replace_events(subsample);

	string seq = read_fasta_file(fasta_file);

	on_hmm::parameters_t param;
	param.load_from_file(param_file);

	on_hmm hmm(&ns_t,prefix_len,param);

	//scramble sequence
	//srand(time(NULL)); ulint nr_changes=0; for(ulint i=0;i<nr_changes;++i) seq[rand()%seq.size()] = base_to_char(base(rand()%4));

	//for(ulint i=0;i<seq.size();++i) seq[i] = 'A';

	//auto root = hmm.get_root();
	//build_tree(root, hmm, ns_t, seq, 0);

	//cout << seq << endl;

	double llh = hmm.log_likelihood(seq, prefix_len);

	cout << llh << endl;

}

int main(int argc, char** argv){

	test_SNPs_llh(argv);

	//compute_llh(argv);
	//print_called(argv);
	//test_hdf5_file(filename);
	//test_HMM(filename,param_file);

}




